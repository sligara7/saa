{
  "template_version": "1.0",
  "template_description": "Template for Level 3 internal module decomposition when interface implementation details are needed",
  "service_name": "REPLACE_WITH_MODULE_NAME",
  "service_id": "REPLACE_WITH_MODULE_ID",
  "hierarchical_tier": "tier_3_internal_modules",
  "component_classification": "function",
  "parent_component": "REPLACE_WITH_PARENT_COMPONENT_ID",
  "purpose": "REPLACE_WITH_SPECIFIC_FUNCTION_PURPOSE",
  "implementation_details": {
    "language": "REPLACE_WITH_LANGUAGE",
    "framework": "REPLACE_WITH_FRAMEWORK",
    "file_path": "REPLACE_WITH_RELATIVE_FILE_PATH",
    "class_name": "REPLACE_WITH_CLASS_NAME",
    "method_names": ["REPLACE_WITH_METHOD_NAMES"],
    "key_functions": ["REPLACE_WITH_KEY_FUNCTIONS"],
    "implementation_status": "REQUIRED: existing | recommended | hypothetical",
    "source_references": {
      "github_repo": "OPTIONAL: GitHub repository URL if available",
      "documentation_links": ["OPTIONAL: Documentation URLs"],
      "file_references": ["OPTIONAL: Specific file paths"],
      "analysis_date": "YYYY-MM-DD",
      "confidence_level": "REQUIRED: high | medium | low"
    },
    "verification_notes": "REQUIRED: Explain whether this is based on actual source analysis, recommendations, or educated guesses",
    "justification": {
      "rationale": "REQUIRED when status is 'recommended' or 'hypothetical': Specific reason for this design choice",
      "standards_reference": "OPTIONAL: Industry standards, RFCs, or specifications that support this approach", 
      "best_practices_reference": "OPTIONAL: Well-established patterns or practices this follows",
      "examples": "OPTIONAL: Similar implementations or systems that use this pattern",
      "trade_offs": "OPTIONAL: Why this approach was chosen over alternatives"
    }
  },
  "interfaces": [
    {
      "name": "INTERFACE_NAME",
      "interface_type": "function_call",
      "communication_pattern": "synchronous",
      "dependency_type": "direct", 
      "implementation_details": {
        "method_signature": "def method_name(param1: type, param2: type) -> return_type",
        "implementation_status": "REQUIRED: existing | recommended | hypothetical",
        "justification": {
          "rationale": "REQUIRED when status is 'recommended' or 'hypothetical': Specific reason for this interface design",
          "standards_reference": "OPTIONAL: Industry standards that support this approach",
          "best_practices_reference": "OPTIONAL: Well-established patterns this follows", 
          "examples": "OPTIONAL: Similar implementations that use this pattern"
        },
        "data_structures": {
          "input_format": "DESCRIBE_INPUT_DATA_STRUCTURE",
          "output_format": "DESCRIBE_OUTPUT_DATA_STRUCTURE"
        },
        "error_handling": ["EXCEPTION_TYPE_1", "EXCEPTION_TYPE_2"],
        "integration_pattern": "DESCRIBE_HOW_OTHER_COMPONENTS_CALL_THIS",
        "source_verification": "REQUIRED: Based on actual source code | Recommended solution | Educated guess - need verification"
      },
      "description": "DETAILED_INTERFACE_DESCRIPTION"
    }
  ],
  "dependencies": [
    "OTHER_MODULE_ID_THIS_CALLS"
  ],
  "integration_points": [
    {
      "target_component": "TARGET_COMPONENT_ID",
      "target_module": "TARGET_MODULE_ID", 
      "interaction_type": "calls | called_by | bidirectional",
      "call_flow": "DESCRIBE_SPECIFIC_CALL_SEQUENCE",
      "data_exchange": "DESCRIBE_WHAT_DATA_IS_EXCHANGED",
      "implementation_notes": "SPECIFIC_GUIDANCE_FOR_DEVELOPERS"
    }
  ],
  "testing_requirements": {
    "unit_tests": ["TEST_SCENARIO_1", "TEST_SCENARIO_2"],
    "integration_tests": ["INTEGRATION_TEST_WITH_TARGET_COMPONENT"],
    "mocking_strategy": "HOW_TO_MOCK_DEPENDENCIES_FOR_TESTING"
  },
  "is_external": false,
  "version": "REQUIRED: X.Y+YYYY-MM-DD (semver-date format)",
  "INSTRUCTIONS": {
    "when_to_use": "Create Level 3 decomposition when interfaces between Level 2 components require specific implementation guidance",
    "hierarchical_tier": "Always use tier_3_internal_modules for internal decomposition",
    "component_classification": "Usually 'function' since these are internal behaviors",
    "implementation_details": "Provide concrete implementation guidance including file paths, class/method names",
    "implementation_status": "Always specify existing/recommended/hypothetical",
    "source_verification": "Always specify verification status and source references when available",
    "confidence_levels": {
      "high": "Based on actual source code analysis",
      "medium": "Based on documentation or partial source analysis", 
      "low": "Educated guess or recommended solution"
    },
    "integration_points": "Specify exactly how this module interfaces with others",
    "directory_structure": "Create in systems/SYSTEM_NAME/COMPONENT_NAME/MODULE_NAME/service_architecture.json",
    "parent_index": "Update parent component's index.json to include internal modules",
    "source_request_guidance": "When source code is not available, explicitly request GitHub repos, documentation, or file references from the user",
    "validation_rules": [
      "parent_component must be a valid Level 2 component",
      "All integration_points must reference real components/modules", 
      "method_signature must be syntactically valid for the specified language",
      "file_path should be relative to component root directory",
      "implementation_status must be clearly specified as existing, recommended, or hypothetical",
      "source_verification must explain the basis for the interface specification"
    ]
  }
}