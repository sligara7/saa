{
  "template_version": "1.0",
  "template_description": "Standard template for Interface Contract Documents (ICDs) - system-agnostic",
  "interface_id": "REQUIRED: unique_identifier_format: provider_to_consumer",
  "provider_component": "REQUIRED: component_id that provides this interface",
  "consumer_component": "REQUIRED: component_id that consumes this interface",
  "interaction_type": "REQUIRED: synchronous|asynchronous|bidirectional|broadcast",
  "domain_type": "REQUIRED: software|biological|social|mechanical|hybrid",
  "contract": {
    "input_specification": {
      "format": "REQUIRED: json|protobuf|xml|electrical_signal|chemical_compound|mechanical_force|information_flow|etc",
      "schema": "REQUIRED: machine-readable schema definition appropriate for format",
      "constraints": [
        "OPTIONAL: size_limits (e.g., max_bytes, max_concentration)",
        "OPTIONAL: rate_limits (e.g., requests_per_second, signal_frequency)",
        "OPTIONAL: ordering_requirements (e.g., must_process_sequentially, can_be_parallel)"
      ],
      "examples": [
        {
          "example_id": "input_example_1",
          "description": "Concrete example of valid input",
          "value": "REQUIRED: actual example in specified format"
        }
      ],
      "validation_rules": [
        "OPTIONAL: how to programmatically validate input"
      ]
    },
    "output_specification": {
      "format": "REQUIRED: json|protobuf|xml|electrical_signal|chemical_compound|mechanical_force|information_flow|etc",
      "schema": "REQUIRED: machine-readable schema definition appropriate for format",
      "success_criteria": "REQUIRED: how to verify output is correct",
      "examples": [
        {
          "example_id": "output_example_1",
          "description": "Concrete example of valid output",
          "value": "REQUIRED: actual example in specified format",
          "corresponding_input": "input_example_1"
        }
      ],
      "validation_rules": [
        "OPTIONAL: how to programmatically validate output"
      ]
    },
    "error_handling": {
      "error_conditions": [
        {
          "error_id": "ERROR_001",
          "condition": "when this error occurs",
          "severity": "critical|high|medium|low"
        }
      ],
      "error_responses": [
        {
          "error_id": "ERROR_001",
          "response_format": "how error is communicated",
          "response_example": "concrete example of error response"
        }
      ],
      "retry_policy": {
        "applicable": "yes|no",
        "max_retries": "OPTIONAL: if applicable",
        "backoff_strategy": "OPTIONAL: exponential|linear|none"
      },
      "fallback_behavior": "REQUIRED: what happens when interface fails completely"
    },
    "timing_constraints": {
      "max_latency": "OPTIONAL: if applicable (e.g., 100ms, 5 minutes, within_1_cell_cycle)",
      "throughput_requirements": "OPTIONAL: if applicable (e.g., 1000_requests_per_second, 50_signals_per_minute)",
      "synchronization_requirements": "OPTIONAL: if applicable (e.g., must_complete_before_next_step, can_be_async)"
    },
    "state_requirements": {
      "stateful": false,
      "state_description": "OPTIONAL: if stateful, what state is maintained across interactions",
      "state_persistence": "OPTIONAL: how state survives component restarts/failures"
    }
  },
  "integration_tests": {
    "test_scenarios": [
      {
        "scenario_id": "happy_path_1",
        "description": "Normal successful interaction",
        "input": "REQUIRED: concrete test input matching input_specification format",
        "expected_output": "REQUIRED: concrete expected output matching output_specification format",
        "success_criteria": "REQUIRED: how to programmatically verify test passed",
        "execution_steps": [
          "step 1: setup",
          "step 2: execute",
          "step 3: verify"
        ]
      },
      {
        "scenario_id": "error_handling_1",
        "description": "Test error condition handling",
        "input": "REQUIRED: input that triggers error",
        "expected_error": "ERROR_001",
        "success_criteria": "REQUIRED: verify error is handled correctly"
      }
    ],
    "contract_verification": {
      "provider_verification": "REQUIRED: how provider can verify it implements contract correctly",
      "consumer_verification": "REQUIRED: how consumer can verify it uses interface correctly",
      "integration_verification": "REQUIRED: how to verify provider and consumer work together"
    },
    "mock_specifications": {
      "provider_mock": "REQUIRED: specification for mock provider for consumer testing",
      "consumer_mock": "REQUIRED: specification for mock consumer for provider testing"
    }
  },
  "dependencies": {
    "depends_on_interfaces": [
      "OPTIONAL: other interface_ids this interface depends on"
    ],
    "environmental_dependencies": [
      "OPTIONAL: external requirements (e.g., network_connectivity, specific_ph_level, authority_relationship)"
    ]
  },
  "metadata": {
    "version": "REQUIRED: X.Y+YYYY-MM-DD semver-date format",
    "last_updated": "YYYY-MM-DD",
    "status": "REQUIRED: draft|review|approved|deprecated",
    "backwards_compatible": true,
    "breaking_changes": [
      "OPTIONAL: if not backwards compatible, list breaking changes"
    ],
    "rationale": "REQUIRED: why this interface exists and why it's designed this way",
    "alternatives_considered": [
      "OPTIONAL: other design options that were considered"
    ]
  },
  "INSTRUCTIONS": {
    "purpose": "Complete specification of how two components interact, sufficient for independent development",
    "usage": "LLM agent developing either provider or consumer component uses this to implement interface correctly",
    "validation": "Both provider and consumer can independently verify their implementation against this contract",
    "domain_adaptation": {
      "software": "Use HTTP/gRPC/message queue specifics in format field",
      "biological": "Use biochemical pathway/signal specifics in format field",
      "social": "Use communication channel/authority flow specifics in format field",
      "mechanical": "Use physical connection/force transmission specifics in format field"
    },
    "required_fields": [
      "interface_id",
      "provider_component",
      "consumer_component",
      "interaction_type",
      "domain_type",
      "contract.input_specification",
      "contract.output_specification",
      "contract.error_handling",
      "integration_tests",
      "metadata.version",
      "metadata.status"
    ]
  }
}
